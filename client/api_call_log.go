/*
 * RingCentral Connect Platform API
 *
 * RingCentral Connect Platform API
 *
 * API version: 1.0.36
 * Contact: platform@ringcentral.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package ringcentral

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type CallLogApiService service

/*
CallLogApiService Delete User Call Log
Deletes filtered call log records.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId Internal identifier of a RingCentral account or tilde (~) to indicate the account logged-in within the current session
 * @param extensionId Internal identifier of an extension or tilde (~) to indicate the extension assigned to the account logged-in within the current session
 * @param optional nil or *DeleteUserCallLogOpts - Optional Parameters:
 * @param "DateTo" (optional.Time) -  The end datetime for records deletion in ISO 8601 format including timezone, for example 2016-03-10T18:07:52.534Z. The default value is current time
 * @param "PhoneNumber" (optional.String) -
 * @param "ExtensionNumber" (optional.String) -
 * @param "Type_" (optional.Interface of []string) -
 * @param "Direction" (optional.Interface of []string) -
 * @param "DateFrom" (optional.Time) -
*/

type DeleteUserCallLogOpts struct {
	DateTo          optional.Time
	PhoneNumber     optional.String
	ExtensionNumber optional.String
	Type_           optional.Interface
	Direction       optional.Interface
	DateFrom        optional.Time
}

func (a *CallLogApiService) DeleteUserCallLog(ctx context.Context, accountId string, extensionId string, localVarOptionals *DeleteUserCallLogOpts) (*http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Delete")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extensionId"+"}", fmt.Sprintf("%v", extensionId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DateTo.IsSet() {
		localVarQueryParams.Add("dateTo", parameterToString(localVarOptionals.DateTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNumber.IsSet() {
		localVarQueryParams.Add("phoneNumber", parameterToString(localVarOptionals.PhoneNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExtensionNumber.IsSet() {
		localVarQueryParams.Add("extensionNumber", parameterToString(localVarOptionals.ExtensionNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.DateFrom.IsSet() {
		localVarQueryParams.Add("dateFrom", parameterToString(localVarOptionals.DateFrom.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
CallLogApiService Get Company Active Calls
Returns records of all calls that are in progress, ordered by start time in descending order.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId Internal identifier of a RingCentral account or tilde (~) to indicate the account logged-in within the current session
 * @param optional nil or *ListCompanyActiveCallsOpts - Optional Parameters:
 * @param "Direction" (optional.Interface of []string) -  The direction for the result records. If not specified, both inbound and outbound records are returned. Multiple values are accepted
 * @param "View" (optional.String) -  View of call records. The same view parameter specified for FSync will be applied for ISync, the view cannot be changed for ISync
 * @param "Type_" (optional.Interface of []string) -  Call type of a record. If not specified, all call types are returned. Multiple values are accepted
 * @param "Transport" (optional.Interface of []string) -  Call transport type. 'PSTN' specifies that a call leg is initiated from the PSTN network provider; 'VoIP' - from an RC phone. By default this filter is disabled
 * @param "Page" (optional.Int32) -  Indicates the page number to retrieve. Only positive number values are accepted
 * @param "PerPage" (optional.Int32) -  Indicates the page size (number of items)
@return ActiveCallsResponse
*/

type ListCompanyActiveCallsOpts struct {
	Direction optional.Interface
	View      optional.String
	Type_     optional.Interface
	Transport optional.Interface
	Page      optional.Int32
	PerPage   optional.Int32
}

func (a *CallLogApiService) ListCompanyActiveCalls(ctx context.Context, accountId string, localVarOptionals *ListCompanyActiveCallsOpts) (ActiveCallsResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActiveCallsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/restapi/v1.0/account/{accountId}/active-calls"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Transport.IsSet() {
		localVarQueryParams.Add("transport", parameterToString(localVarOptionals.Transport.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("perPage", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ActiveCallsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CallLogApiService Get User Active Calls
Returns records of all extension calls that are in progress, ordered by start time in descending order.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId Internal identifier of a RingCentral account or tilde (~) to indicate the account logged-in within the current session
 * @param extensionId Internal identifier of an extension or tilde (~) to indicate the extension assigned to the account logged-in within the current session
 * @param optional nil or *ListExtensionActiveCallsOpts - Optional Parameters:
 * @param "Direction" (optional.Interface of []string) -  The direction for the result records. If not specified, both inbound and outbound records are returned. Multiple values are accepted
 * @param "View" (optional.String) -  View of call records. The same view parameter specified for FSync will be applied for ISync, the view cannot be changed for ISync
 * @param "Type_" (optional.Interface of []string) -  Call type of a record. If not specified, all call types are returned. Multiple values are accepted
 * @param "Page" (optional.Int32) -  Indicates the page number to retrieve. Only positive number values are allowed
 * @param "PerPage" (optional.Int32) -  Indicates the page size (number of items)
@return ActiveCallsResponse
*/

type ListExtensionActiveCallsOpts struct {
	Direction optional.Interface
	View      optional.String
	Type_     optional.Interface
	Page      optional.Int32
	PerPage   optional.Int32
}

func (a *CallLogApiService) ListExtensionActiveCalls(ctx context.Context, accountId string, extensionId string, localVarOptionals *ListExtensionActiveCallsOpts) (ActiveCallsResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ActiveCallsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/restapi/v1.0/account/{accountId}/extension/{extensionId}/active-calls"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extensionId"+"}", fmt.Sprintf("%v", extensionId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("perPage", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v ActiveCallsResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CallLogApiService Get Company Call Log Records
Returns call log records filtered by parameters specified.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId Internal identifier of a RingCentral account or tilde (~) to indicate the account logged-in within the current session
 * @param optional nil or *ReadCompanyCallLogOpts - Optional Parameters:
 * @param "ExtensionNumber" (optional.String) -  Extension number of a user. If specified, returns call log for a particular extension only
 * @param "PhoneNumber" (optional.String) -  Phone number of a caller/call recipient. If specified, returns all calls (both incoming and outcoming) with the phone number specified. Cannot be specified together with the extensionNumber filter
 * @param "Direction" (optional.Interface of []string) -  The direction for the result records. If not specified, both inbound and outbound records are returned. Multiple values are accepted
 * @param "Type_" (optional.Interface of []string) -  Call type of a record. If not specified, all call types are returned. Multiple values are accepted
 * @param "View" (optional.String) -  View of call records. The same view parameter specified for FSync will be applied for ISync, the view cannot be changed for ISync
 * @param "WithRecording" (optional.Bool) -  **Deprecated**. Supported for compatibility reasons only. `true` if only recorded calls are returned. The default value is `false`. If both `withRecording` and `recordingType` are specified, `withRecording` is ignored
 * @param "RecordingType" (optional.String) -  Type of a call recording. If not specified, then calls without recordings are also returned
 * @param "DateFrom" (optional.Time) -  The start datetime for resulting records in ISO 8601 format including timezone, for example 2016-03-10T18:07:52.534Z. The default value is dateTo minus 24 hours
 * @param "DateTo" (optional.Time) -  The end datetime for resulting records in ISO 8601 format including timezone, for example 2016-03-10T18:07:52.534Z. The default value is current time
 * @param "Page" (optional.Int32) -  Indicates the page number to retrieve. Only positive number values are accepted
 * @param "PerPage" (optional.Int32) -  Indicates the page size (number of items)
 * @param "SessionId" (optional.String) -  Internal identifier of a session
@return AccountCallLogResponse
*/

type ReadCompanyCallLogOpts struct {
	ExtensionNumber optional.String
	PhoneNumber     optional.String
	Direction       optional.Interface
	Type_           optional.Interface
	View            optional.String
	WithRecording   optional.Bool
	RecordingType   optional.String
	DateFrom        optional.Time
	DateTo          optional.Time
	Page            optional.Int32
	PerPage         optional.Int32
	SessionId       optional.String
}

func (a *CallLogApiService) ReadCompanyCallLog(ctx context.Context, accountId string, localVarOptionals *ReadCompanyCallLogOpts) (AccountCallLogResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccountCallLogResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/restapi/v1.0/account/{accountId}/call-log"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ExtensionNumber.IsSet() {
		localVarQueryParams.Add("extensionNumber", parameterToString(localVarOptionals.ExtensionNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNumber.IsSet() {
		localVarQueryParams.Add("phoneNumber", parameterToString(localVarOptionals.PhoneNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithRecording.IsSet() {
		localVarQueryParams.Add("withRecording", parameterToString(localVarOptionals.WithRecording.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordingType.IsSet() {
		localVarQueryParams.Add("recordingType", parameterToString(localVarOptionals.RecordingType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateFrom.IsSet() {
		localVarQueryParams.Add("dateFrom", parameterToString(localVarOptionals.DateFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateTo.IsSet() {
		localVarQueryParams.Add("dateTo", parameterToString(localVarOptionals.DateTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("perPage", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SessionId.IsSet() {
		localVarQueryParams.Add("sessionId", parameterToString(localVarOptionals.SessionId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v AccountCallLogResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CallLogApiService Get Company Call Log Record(s)
Returns individual call log record(s) by ID(s). Batch request is supported.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId Internal identifier of a RingCentral account or tilde (~) to indicate the account logged-in within the current session
 * @param callRecordId Internal identifier of a call log record
@return CompanyCallLogRecord
*/
func (a *CallLogApiService) ReadCompanyCallRecord(ctx context.Context, accountId string, callRecordId string) (CompanyCallLogRecord, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CompanyCallLogRecord
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/restapi/v1.0/account/{accountId}/call-log/{callRecordId}"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"callRecordId"+"}", fmt.Sprintf("%v", callRecordId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v CompanyCallLogRecord
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CallLogApiService Get User Call Log Records
Returns call log records filtered by parameters specified.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId Internal identifier of a RingCentral account or tilde (~) to indicate the account logged-in within the current session
 * @param extensionId Internal identifier of an extension or tilde (~) to indicate the extension assigned to the account logged-in within the current session
 * @param optional nil or *ReadUserCallLogOpts - Optional Parameters:
 * @param "ExtensionNumber" (optional.String) -  Extension number of a user. If specified, returns call log for a particular extension only
 * @param "ShowBlocked" (optional.Bool) -  If 'True' then calls from/to blocked numbers are returned
 * @param "PhoneNumber" (optional.String) -  Phone number of a caller/callee. If specified, returns all calls (both incoming and outcoming) with the phone number specified
 * @param "Direction" (optional.Interface of []string) -  The direction for the resulting records. If not specified, both inbound and outbound records are returned. Multiple values are accepted
 * @param "SessionId" (optional.String) -  Internal identifier of a session
 * @param "Type_" (optional.Interface of []string) -  Call type of a record. It is allowed to specify more than one type. If not specified, all call types are returned. Multiple values are accepted
 * @param "Transport" (optional.Interface of []string) -  Call transport type. 'PSTN' specifies that a call leg is initiated from the PSTN network provider; 'VoIP' - from an RC phone. By default this filter is disabled
 * @param "View" (optional.String) -  View of call records. The same view parameter specified for FSync will be applied for ISync, the view cannot be changed for ISync
 * @param "WithRecording" (optional.Bool) -  **Deprecated**. Supported for compatibility reasons. `True` if only recorded calls are returned. If both `withRecording` and `recordingType` are specified, then `withRecording` is ignored
 * @param "RecordingType" (optional.String) -  Type of a call recording. If not specified, then calls without recordings are also returned
 * @param "DateTo" (optional.Time) -  The end datetime for resulting records in ISO 8601 format including timezone, for example 2016-03-10T18:07:52.534Z. The default value is current time
 * @param "DateFrom" (optional.Time) -  The start datetime for resulting records in ISO 8601 format including timezone, for example 2016-03-10T18:07:52.534Z. The default value is dateTo minus 24 hours
 * @param "Page" (optional.Int32) -  Indicates the page number to retrieve. Only positive number values are allowed
 * @param "PerPage" (optional.Int32) -  Indicates the page size (number of items)
 * @param "ShowDeleted" (optional.Bool) -  If 'True' then deleted calls are returned
@return UserCallLogResponse
*/

type ReadUserCallLogOpts struct {
	ExtensionNumber optional.String
	ShowBlocked     optional.Bool
	PhoneNumber     optional.String
	Direction       optional.Interface
	SessionId       optional.String
	Type_           optional.Interface
	Transport       optional.Interface
	View            optional.String
	WithRecording   optional.Bool
	RecordingType   optional.String
	DateTo          optional.Time
	DateFrom        optional.Time
	Page            optional.Int32
	PerPage         optional.Int32
	ShowDeleted     optional.Bool
}

func (a *CallLogApiService) ReadUserCallLog(ctx context.Context, accountId string, extensionId string, localVarOptionals *ReadUserCallLogOpts) (UserCallLogResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UserCallLogResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extensionId"+"}", fmt.Sprintf("%v", extensionId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ExtensionNumber.IsSet() {
		localVarQueryParams.Add("extensionNumber", parameterToString(localVarOptionals.ExtensionNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShowBlocked.IsSet() {
		localVarQueryParams.Add("showBlocked", parameterToString(localVarOptionals.ShowBlocked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PhoneNumber.IsSet() {
		localVarQueryParams.Add("phoneNumber", parameterToString(localVarOptionals.PhoneNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Direction.IsSet() {
		localVarQueryParams.Add("direction", parameterToString(localVarOptionals.Direction.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SessionId.IsSet() {
		localVarQueryParams.Add("sessionId", parameterToString(localVarOptionals.SessionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.Transport.IsSet() {
		localVarQueryParams.Add("transport", parameterToString(localVarOptionals.Transport.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithRecording.IsSet() {
		localVarQueryParams.Add("withRecording", parameterToString(localVarOptionals.WithRecording.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordingType.IsSet() {
		localVarQueryParams.Add("recordingType", parameterToString(localVarOptionals.RecordingType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateTo.IsSet() {
		localVarQueryParams.Add("dateTo", parameterToString(localVarOptionals.DateTo.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateFrom.IsSet() {
		localVarQueryParams.Add("dateFrom", parameterToString(localVarOptionals.DateFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("perPage", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShowDeleted.IsSet() {
		localVarQueryParams.Add("showDeleted", parameterToString(localVarOptionals.ShowDeleted.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v UserCallLogResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CallLogApiService Get User Call Record
Returns call log records by ID.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param callRecordId
 * @param extensionId Internal identifier of an extension or tilde (~) to indicate the extension assigned to the account logged-in within the current session
 * @param accountId Internal identifier of a RingCentral account or tilde (~) to indicate the account logged-in within the current session
 * @param optional nil or *ReadUserCallRecordOpts - Optional Parameters:
 * @param "View" (optional.String) -  View of call records. The same view parameter specified for FSync will be applied for ISync, the view cannot be changed for ISync
@return UserCallLogRecord
*/

type ReadUserCallRecordOpts struct {
	View optional.String
}

func (a *CallLogApiService) ReadUserCallRecord(ctx context.Context, callRecordId []string, extensionId string, accountId string, localVarOptionals *ReadUserCallRecordOpts) (UserCallLogRecord, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UserCallLogRecord
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log/{callRecordId}"
	localVarPath = strings.Replace(localVarPath, "{"+"callRecordId"+"}", fmt.Sprintf("%v", callRecordId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extensionId"+"}", fmt.Sprintf("%v", extensionId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v UserCallLogRecord
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
CallLogApiService Sync User Call Log
Synchronizes call log records
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId Internal identifier of a RingCentral account or tilde (~) to indicate the account logged-in within the current session
 * @param extensionId Internal identifier of an extension or tilde (~) to indicate the extension assigned to the account logged-in within the current session
 * @param optional nil or *SyncUserCallLogOpts - Optional Parameters:
 * @param "SyncType" (optional.Interface of []string) -  Type of synchronization
 * @param "SyncToken" (optional.String) -  Value of syncToken property of last sync request response
 * @param "DateFrom" (optional.Time) -  The start datetime for resulting records in ISO 8601 format including timezone, for example 2016-03-10T18:07:52.534Z. The default value is the current moment
 * @param "RecordCount" (optional.Int32) -  For 'FSync' the parameter is mandatory, it limits the number of records to be returned in response. For 'ISync' it specifies with how many records to extend sync Frame to the past, the maximum number of records is 250
 * @param "StatusGroup" (optional.Interface of []string) -  Type of calls to be returned. The default value is 'All'
 * @param "View" (optional.String) -  View of call records. The same view parameter specified for FSync will be applied for ISync, the view cannot be changed for ISync
 * @param "ShowDeleted" (optional.Bool) -  Supproted for ISync. If 'True' then deleted call records are returned
@return CallLogSync
*/

type SyncUserCallLogOpts struct {
	SyncType    optional.Interface
	SyncToken   optional.String
	DateFrom    optional.Time
	RecordCount optional.Int32
	StatusGroup optional.Interface
	View        optional.String
	ShowDeleted optional.Bool
}

func (a *CallLogApiService) SyncUserCallLog(ctx context.Context, accountId string, extensionId string, localVarOptionals *SyncUserCallLogOpts) (CallLogSync, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CallLogSync
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/restapi/v1.0/account/{accountId}/extension/{extensionId}/call-log-sync"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extensionId"+"}", fmt.Sprintf("%v", extensionId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.SyncType.IsSet() {
		localVarQueryParams.Add("syncType", parameterToString(localVarOptionals.SyncType.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.SyncToken.IsSet() {
		localVarQueryParams.Add("syncToken", parameterToString(localVarOptionals.SyncToken.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DateFrom.IsSet() {
		localVarQueryParams.Add("dateFrom", parameterToString(localVarOptionals.DateFrom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RecordCount.IsSet() {
		localVarQueryParams.Add("recordCount", parameterToString(localVarOptionals.RecordCount.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StatusGroup.IsSet() {
		localVarQueryParams.Add("statusGroup", parameterToString(localVarOptionals.StatusGroup.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ShowDeleted.IsSet() {
		localVarQueryParams.Add("showDeleted", parameterToString(localVarOptionals.ShowDeleted.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 0 {
			var v CallLogSync
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
