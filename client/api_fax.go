/*
 * RingCentral Connect Platform API
 *
 * RingCentral Connect Platform API
 *
 * API version: 1.0.36
 * Contact: platform@ringcentral.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package ringcentral

import (
	"context"
	"fmt"
	"github.com/antihax/optional"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type FaxApiService service

/*
FaxApiService Create Fax Message
Creates and sends/resends a new fax message. Resend can be done if sending failed.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param accountId Internal identifier of a RingCentral account (integer) or tilde (~) to indicate the account which was logged-in within the current session.
 * @param extensionId Internal identifier of an extension (integer) or tilde (~) to indicate the extension assigned to the account logged-in within the current session
 * @param attachment File to upload
 * @param to To Phone Number
 * @param optional nil or *CreateFaxMessageOpts - Optional Parameters:
 * @param "FaxResolution" (optional.String) -  Resolution of Fax
 * @param "SendTime" (optional.Time) -  Timestamp to send fax at. If not specified (current or the past), the fax is sent immediately
 * @param "IsoCode" (optional.String) -  ISO Code. e.g UK
 * @param "CoverIndex" (optional.Int32) -  Cover page identifier. For the list of available cover page identifiers please call the method Fax Cover Pages. If not specified, the default cover page which is configured in 'Outbound Fax Settings' is attached
 * @param "CoverPageText" (optional.String) -  Cover page text, entered by the fax sender and printed on the cover page. Maximum length is limited to 1024 symbols
@return FaxResponse
*/

type CreateFaxMessageOpts struct {
	FaxResolution optional.String
	SendTime      optional.Time
	IsoCode       optional.String
	CoverIndex    optional.Int32
	CoverPageText optional.String
}

func (a *FaxApiService) CreateFaxMessage(ctx context.Context, accountId string, extensionId string, attachment *os.File, to []string, localVarOptionals *CreateFaxMessageOpts) (FaxResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Post")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  FaxResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/restapi/v1.0/account/{accountId}/extension/{extensionId}/fax"
	localVarPath = strings.Replace(localVarPath, "{"+"accountId"+"}", fmt.Sprintf("%v", accountId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"extensionId"+"}", fmt.Sprintf("%v", extensionId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	localVarFormFileName = "attachment"
	localVarFile := attachment
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.FaxResolution.IsSet() {
		localVarFormParams.Add("faxResolution", parameterToString(localVarOptionals.FaxResolution.Value(), ""))
	}
	localVarFormParams.Add("to", parameterToString(to, "csv"))
	if localVarOptionals != nil && localVarOptionals.SendTime.IsSet() {
		localVarFormParams.Add("sendTime", parameterToString(localVarOptionals.SendTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IsoCode.IsSet() {
		localVarFormParams.Add("isoCode", parameterToString(localVarOptionals.IsoCode.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CoverIndex.IsSet() {
		localVarFormParams.Add("coverIndex", parameterToString(localVarOptionals.CoverIndex.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CoverPageText.IsSet() {
		localVarFormParams.Add("coverPageText", parameterToString(localVarOptionals.CoverPageText.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v FaxResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
FaxApiService Get Fax Cover Page List
Returns fax cover pages available for the current extension.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ListFaxCoverPagesOpts - Optional Parameters:
 * @param "Page" (optional.Int32) -  Indicates the page number to retrieve. Only positive number values are accepted
 * @param "PerPage" (optional.Int32) -  Indicates the page size (number of items)
@return ListFaxCoverPagesResponse
*/

type ListFaxCoverPagesOpts struct {
	Page    optional.Int32
	PerPage optional.Int32
}

func (a *FaxApiService) ListFaxCoverPages(ctx context.Context, localVarOptionals *ListFaxCoverPagesOpts) (ListFaxCoverPagesResponse, *http.Response, error) {
	var (
		localVarHttpMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListFaxCoverPagesResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/restapi/v1.0/dictionary/fax-cover-page"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Page.IsSet() {
		localVarQueryParams.Add("page", parameterToString(localVarOptionals.Page.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PerPage.IsSet() {
		localVarQueryParams.Add("perPage", parameterToString(localVarOptionals.PerPage.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ListFaxCoverPagesResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHttpResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
